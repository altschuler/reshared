schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""
expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
expression to compare columns of type String. All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

"""
columns and relationships of "auth.account_providers"
"""
type auth_account_providers {
  """An object relationship"""
  account: auth_accounts!
  account_id: uuid!
  auth_provider: String!
  auth_provider_unique_id: String!
  created_at: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: auth_providers!
  updated_at: timestamptz!
}

"""
aggregated selection of "auth.account_providers"
"""
type auth_account_providers_aggregate {
  aggregate: auth_account_providers_aggregate_fields
  nodes: [auth_account_providers!]!
}

"""
aggregate fields of "auth.account_providers"
"""
type auth_account_providers_aggregate_fields {
  count(columns: [auth_account_providers_select_column!], distinct: Boolean): Int
  max: auth_account_providers_max_fields
  min: auth_account_providers_min_fields
}

"""
order by aggregate values of table "auth.account_providers"
"""
input auth_account_providers_aggregate_order_by {
  count: order_by
  max: auth_account_providers_max_order_by
  min: auth_account_providers_min_order_by
}

"""
input type for inserting array relation for remote table "auth.account_providers"
"""
input auth_account_providers_arr_rel_insert_input {
  data: [auth_account_providers_insert_input!]!
  on_conflict: auth_account_providers_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.account_providers". All fields are combined with a logical 'AND'.
"""
input auth_account_providers_bool_exp {
  _and: [auth_account_providers_bool_exp]
  _not: auth_account_providers_bool_exp
  _or: [auth_account_providers_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  auth_provider: String_comparison_exp
  auth_provider_unique_id: String_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: auth_providers_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "auth.account_providers"
"""
enum auth_account_providers_constraint {
  """unique or primary key constraint"""
  account_providers_account_id_auth_provider_key

  """unique or primary key constraint"""
  account_providers_auth_provider_auth_provider_unique_id_key

  """unique or primary key constraint"""
  account_providers_pkey
}

"""
input type for inserting data into table "auth.account_providers"
"""
input auth_account_providers_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  provider: auth_providers_obj_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type auth_account_providers_max_fields {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "auth.account_providers"
"""
input auth_account_providers_max_order_by {
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type auth_account_providers_min_fields {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "auth.account_providers"
"""
input auth_account_providers_min_order_by {
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "auth.account_providers"
"""
type auth_account_providers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_account_providers!]!
}

"""
input type for inserting object relation for remote table "auth.account_providers"
"""
input auth_account_providers_obj_rel_insert_input {
  data: auth_account_providers_insert_input!
  on_conflict: auth_account_providers_on_conflict
}

"""
on conflict condition type for table "auth.account_providers"
"""
input auth_account_providers_on_conflict {
  constraint: auth_account_providers_constraint!
  update_columns: [auth_account_providers_update_column!]!
  where: auth_account_providers_bool_exp
}

"""
ordering options when selecting data from "auth.account_providers"
"""
input auth_account_providers_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  auth_provider: order_by
  auth_provider_unique_id: order_by
  created_at: order_by
  id: order_by
  provider: auth_providers_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "auth.account_providers"
"""
input auth_account_providers_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.account_providers"
"""
enum auth_account_providers_select_column {
  """column name"""
  account_id

  """column name"""
  auth_provider

  """column name"""
  auth_provider_unique_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "auth.account_providers"
"""
input auth_account_providers_set_input {
  account_id: uuid
  auth_provider: String
  auth_provider_unique_id: String
  created_at: timestamptz
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "auth.account_providers"
"""
enum auth_account_providers_update_column {
  """column name"""
  account_id

  """column name"""
  auth_provider

  """column name"""
  auth_provider_unique_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  updated_at
}

"""
columns and relationships of "auth.account_roles"
"""
type auth_account_roles {
  """An object relationship"""
  account: auth_accounts!
  account_id: uuid!
  created_at: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: auth_roles!
}

"""
aggregated selection of "auth.account_roles"
"""
type auth_account_roles_aggregate {
  aggregate: auth_account_roles_aggregate_fields
  nodes: [auth_account_roles!]!
}

"""
aggregate fields of "auth.account_roles"
"""
type auth_account_roles_aggregate_fields {
  count(columns: [auth_account_roles_select_column!], distinct: Boolean): Int
  max: auth_account_roles_max_fields
  min: auth_account_roles_min_fields
}

"""
order by aggregate values of table "auth.account_roles"
"""
input auth_account_roles_aggregate_order_by {
  count: order_by
  max: auth_account_roles_max_order_by
  min: auth_account_roles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.account_roles"
"""
input auth_account_roles_arr_rel_insert_input {
  data: [auth_account_roles_insert_input!]!
  on_conflict: auth_account_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.account_roles". All fields are combined with a logical 'AND'.
"""
input auth_account_roles_bool_exp {
  _and: [auth_account_roles_bool_exp]
  _not: auth_account_roles_bool_exp
  _or: [auth_account_roles_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: auth_roles_bool_exp
}

"""
unique or primary key constraints on table "auth.account_roles"
"""
enum auth_account_roles_constraint {
  """unique or primary key constraint"""
  account_roles_pkey

  """unique or primary key constraint"""
  user_roles_account_id_role_key
}

"""
input type for inserting data into table "auth.account_roles"
"""
input auth_account_roles_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
  roleByRole: auth_roles_obj_rel_insert_input
}

"""aggregate max on columns"""
type auth_account_roles_max_fields {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
order by max() on columns of table "auth.account_roles"
"""
input auth_account_roles_max_order_by {
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
}

"""aggregate min on columns"""
type auth_account_roles_min_fields {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
order by min() on columns of table "auth.account_roles"
"""
input auth_account_roles_min_order_by {
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
}

"""
response of any mutation on the table "auth.account_roles"
"""
type auth_account_roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_account_roles!]!
}

"""
input type for inserting object relation for remote table "auth.account_roles"
"""
input auth_account_roles_obj_rel_insert_input {
  data: auth_account_roles_insert_input!
  on_conflict: auth_account_roles_on_conflict
}

"""
on conflict condition type for table "auth.account_roles"
"""
input auth_account_roles_on_conflict {
  constraint: auth_account_roles_constraint!
  update_columns: [auth_account_roles_update_column!]!
  where: auth_account_roles_bool_exp
}

"""
ordering options when selecting data from "auth.account_roles"
"""
input auth_account_roles_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  created_at: order_by
  id: order_by
  role: order_by
  roleByRole: auth_roles_order_by
}

"""
primary key columns input for table: "auth.account_roles"
"""
input auth_account_roles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.account_roles"
"""
enum auth_account_roles_select_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role
}

"""
input type for updating data in table "auth.account_roles"
"""
input auth_account_roles_set_input {
  account_id: uuid
  created_at: timestamptz
  id: uuid
  role: String
}

"""
update columns of table "auth.account_roles"
"""
enum auth_account_roles_update_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  role
}

"""
columns and relationships of "auth.accounts"
"""
type auth_accounts {
  """An array relationship"""
  account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """An aggregated array relationship"""
  account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """An array relationship"""
  account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """An aggregated array relationship"""
  account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!
  active: Boolean!
  created_at: timestamptz!
  custom_register_data(
    """JSON select path"""
    path: String
  ): jsonb
  default_role: String!
  email: citext
  id: uuid!
  is_anonymous: Boolean!
  mfa_enabled: Boolean!
  new_email: citext
  otp_secret: String
  password_hash: String

  """An array relationship"""
  refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """An aggregated array relationship"""
  refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """An object relationship"""
  role: auth_roles!
  ticket: uuid!
  ticket_expires_at: timestamptz!
  updated_at: timestamptz!

  """An object relationship"""
  user: users!
  user_id: uuid!
}

"""
aggregated selection of "auth.accounts"
"""
type auth_accounts_aggregate {
  aggregate: auth_accounts_aggregate_fields
  nodes: [auth_accounts!]!
}

"""
aggregate fields of "auth.accounts"
"""
type auth_accounts_aggregate_fields {
  count(columns: [auth_accounts_select_column!], distinct: Boolean): Int
  max: auth_accounts_max_fields
  min: auth_accounts_min_fields
}

"""
order by aggregate values of table "auth.accounts"
"""
input auth_accounts_aggregate_order_by {
  count: order_by
  max: auth_accounts_max_order_by
  min: auth_accounts_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input auth_accounts_append_input {
  custom_register_data: jsonb
}

"""
input type for inserting array relation for remote table "auth.accounts"
"""
input auth_accounts_arr_rel_insert_input {
  data: [auth_accounts_insert_input!]!
  on_conflict: auth_accounts_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.accounts". All fields are combined with a logical 'AND'.
"""
input auth_accounts_bool_exp {
  _and: [auth_accounts_bool_exp]
  _not: auth_accounts_bool_exp
  _or: [auth_accounts_bool_exp]
  account_providers: auth_account_providers_bool_exp
  account_roles: auth_account_roles_bool_exp
  active: Boolean_comparison_exp
  created_at: timestamptz_comparison_exp
  custom_register_data: jsonb_comparison_exp
  default_role: String_comparison_exp
  email: citext_comparison_exp
  id: uuid_comparison_exp
  is_anonymous: Boolean_comparison_exp
  mfa_enabled: Boolean_comparison_exp
  new_email: citext_comparison_exp
  otp_secret: String_comparison_exp
  password_hash: String_comparison_exp
  refresh_tokens: auth_refresh_tokens_bool_exp
  role: auth_roles_bool_exp
  ticket: uuid_comparison_exp
  ticket_expires_at: timestamptz_comparison_exp
  updated_at: timestamptz_comparison_exp
  user: users_bool_exp
  user_id: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.accounts"
"""
enum auth_accounts_constraint {
  """unique or primary key constraint"""
  accounts_email_key

  """unique or primary key constraint"""
  accounts_new_email_key

  """unique or primary key constraint"""
  accounts_pkey

  """unique or primary key constraint"""
  accounts_user_id_key
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input auth_accounts_delete_at_path_input {
  custom_register_data: [String]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input auth_accounts_delete_elem_input {
  custom_register_data: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input auth_accounts_delete_key_input {
  custom_register_data: String
}

"""
input type for inserting data into table "auth.accounts"
"""
input auth_accounts_insert_input {
  account_providers: auth_account_providers_arr_rel_insert_input
  account_roles: auth_account_roles_arr_rel_insert_input
  active: Boolean
  created_at: timestamptz
  custom_register_data: jsonb
  default_role: String
  email: citext
  id: uuid
  is_anonymous: Boolean
  mfa_enabled: Boolean
  new_email: citext
  otp_secret: String
  password_hash: String
  refresh_tokens: auth_refresh_tokens_arr_rel_insert_input
  role: auth_roles_obj_rel_insert_input
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user: users_obj_rel_insert_input
  user_id: uuid
}

"""aggregate max on columns"""
type auth_accounts_max_fields {
  created_at: timestamptz
  default_role: String
  email: citext
  id: uuid
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by max() on columns of table "auth.accounts"
"""
input auth_accounts_max_order_by {
  created_at: order_by
  default_role: order_by
  email: order_by
  id: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""aggregate min on columns"""
type auth_accounts_min_fields {
  created_at: timestamptz
  default_role: String
  email: citext
  id: uuid
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
order by min() on columns of table "auth.accounts"
"""
input auth_accounts_min_order_by {
  created_at: order_by
  default_role: order_by
  email: order_by
  id: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user_id: order_by
}

"""
response of any mutation on the table "auth.accounts"
"""
type auth_accounts_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_accounts!]!
}

"""
input type for inserting object relation for remote table "auth.accounts"
"""
input auth_accounts_obj_rel_insert_input {
  data: auth_accounts_insert_input!
  on_conflict: auth_accounts_on_conflict
}

"""
on conflict condition type for table "auth.accounts"
"""
input auth_accounts_on_conflict {
  constraint: auth_accounts_constraint!
  update_columns: [auth_accounts_update_column!]!
  where: auth_accounts_bool_exp
}

"""
ordering options when selecting data from "auth.accounts"
"""
input auth_accounts_order_by {
  account_providers_aggregate: auth_account_providers_aggregate_order_by
  account_roles_aggregate: auth_account_roles_aggregate_order_by
  active: order_by
  created_at: order_by
  custom_register_data: order_by
  default_role: order_by
  email: order_by
  id: order_by
  is_anonymous: order_by
  mfa_enabled: order_by
  new_email: order_by
  otp_secret: order_by
  password_hash: order_by
  refresh_tokens_aggregate: auth_refresh_tokens_aggregate_order_by
  role: auth_roles_order_by
  ticket: order_by
  ticket_expires_at: order_by
  updated_at: order_by
  user: users_order_by
  user_id: order_by
}

"""
primary key columns input for table: "auth.accounts"
"""
input auth_accounts_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input auth_accounts_prepend_input {
  custom_register_data: jsonb
}

"""
select columns of table "auth.accounts"
"""
enum auth_accounts_select_column {
  """column name"""
  active

  """column name"""
  created_at

  """column name"""
  custom_register_data

  """column name"""
  default_role

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_anonymous

  """column name"""
  mfa_enabled

  """column name"""
  new_email

  """column name"""
  otp_secret

  """column name"""
  password_hash

  """column name"""
  ticket

  """column name"""
  ticket_expires_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
input type for updating data in table "auth.accounts"
"""
input auth_accounts_set_input {
  active: Boolean
  created_at: timestamptz
  custom_register_data: jsonb
  default_role: String
  email: citext
  id: uuid
  is_anonymous: Boolean
  mfa_enabled: Boolean
  new_email: citext
  otp_secret: String
  password_hash: String
  ticket: uuid
  ticket_expires_at: timestamptz
  updated_at: timestamptz
  user_id: uuid
}

"""
update columns of table "auth.accounts"
"""
enum auth_accounts_update_column {
  """column name"""
  active

  """column name"""
  created_at

  """column name"""
  custom_register_data

  """column name"""
  default_role

  """column name"""
  email

  """column name"""
  id

  """column name"""
  is_anonymous

  """column name"""
  mfa_enabled

  """column name"""
  new_email

  """column name"""
  otp_secret

  """column name"""
  password_hash

  """column name"""
  ticket

  """column name"""
  ticket_expires_at

  """column name"""
  updated_at

  """column name"""
  user_id
}

"""
columns and relationships of "auth.providers"
"""
type auth_providers {
  """An array relationship"""
  account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """An aggregated array relationship"""
  account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!
  provider: String!
}

"""
aggregated selection of "auth.providers"
"""
type auth_providers_aggregate {
  aggregate: auth_providers_aggregate_fields
  nodes: [auth_providers!]!
}

"""
aggregate fields of "auth.providers"
"""
type auth_providers_aggregate_fields {
  count(columns: [auth_providers_select_column!], distinct: Boolean): Int
  max: auth_providers_max_fields
  min: auth_providers_min_fields
}

"""
order by aggregate values of table "auth.providers"
"""
input auth_providers_aggregate_order_by {
  count: order_by
  max: auth_providers_max_order_by
  min: auth_providers_min_order_by
}

"""
input type for inserting array relation for remote table "auth.providers"
"""
input auth_providers_arr_rel_insert_input {
  data: [auth_providers_insert_input!]!
  on_conflict: auth_providers_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input auth_providers_bool_exp {
  _and: [auth_providers_bool_exp]
  _not: auth_providers_bool_exp
  _or: [auth_providers_bool_exp]
  account_providers: auth_account_providers_bool_exp
  provider: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum auth_providers_constraint {
  """unique or primary key constraint"""
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input auth_providers_insert_input {
  account_providers: auth_account_providers_arr_rel_insert_input
  provider: String
}

"""aggregate max on columns"""
type auth_providers_max_fields {
  provider: String
}

"""
order by max() on columns of table "auth.providers"
"""
input auth_providers_max_order_by {
  provider: order_by
}

"""aggregate min on columns"""
type auth_providers_min_fields {
  provider: String
}

"""
order by min() on columns of table "auth.providers"
"""
input auth_providers_min_order_by {
  provider: order_by
}

"""
response of any mutation on the table "auth.providers"
"""
type auth_providers_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_providers!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input auth_providers_obj_rel_insert_input {
  data: auth_providers_insert_input!
  on_conflict: auth_providers_on_conflict
}

"""
on conflict condition type for table "auth.providers"
"""
input auth_providers_on_conflict {
  constraint: auth_providers_constraint!
  update_columns: [auth_providers_update_column!]!
  where: auth_providers_bool_exp
}

"""
ordering options when selecting data from "auth.providers"
"""
input auth_providers_order_by {
  account_providers_aggregate: auth_account_providers_aggregate_order_by
  provider: order_by
}

"""
primary key columns input for table: "auth.providers"
"""
input auth_providers_pk_columns_input {
  provider: String!
}

"""
select columns of table "auth.providers"
"""
enum auth_providers_select_column {
  """column name"""
  provider
}

"""
input type for updating data in table "auth.providers"
"""
input auth_providers_set_input {
  provider: String
}

"""
update columns of table "auth.providers"
"""
enum auth_providers_update_column {
  """column name"""
  provider
}

"""
columns and relationships of "auth.refresh_tokens"
"""
type auth_refresh_tokens {
  """An object relationship"""
  account: auth_accounts!
  account_id: uuid!
  created_at: timestamptz!
  expires_at: timestamptz!
  refresh_token: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate {
  aggregate: auth_refresh_tokens_aggregate_fields
  nodes: [auth_refresh_tokens!]!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type auth_refresh_tokens_aggregate_fields {
  count(columns: [auth_refresh_tokens_select_column!], distinct: Boolean): Int
  max: auth_refresh_tokens_max_fields
  min: auth_refresh_tokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_aggregate_order_by {
  count: order_by
  max: auth_refresh_tokens_max_order_by
  min: auth_refresh_tokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input auth_refresh_tokens_arr_rel_insert_input {
  data: [auth_refresh_tokens_insert_input!]!
  on_conflict: auth_refresh_tokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input auth_refresh_tokens_bool_exp {
  _and: [auth_refresh_tokens_bool_exp]
  _not: auth_refresh_tokens_bool_exp
  _or: [auth_refresh_tokens_bool_exp]
  account: auth_accounts_bool_exp
  account_id: uuid_comparison_exp
  created_at: timestamptz_comparison_exp
  expires_at: timestamptz_comparison_exp
  refresh_token: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_constraint {
  """unique or primary key constraint"""
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input auth_refresh_tokens_insert_input {
  account: auth_accounts_obj_rel_insert_input
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""aggregate max on columns"""
type auth_refresh_tokens_max_fields {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_max_order_by {
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""aggregate min on columns"""
type auth_refresh_tokens_min_fields {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input auth_refresh_tokens_min_order_by {
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type auth_refresh_tokens_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_refresh_tokens!]!
}

"""
input type for inserting object relation for remote table "auth.refresh_tokens"
"""
input auth_refresh_tokens_obj_rel_insert_input {
  data: auth_refresh_tokens_insert_input!
  on_conflict: auth_refresh_tokens_on_conflict
}

"""
on conflict condition type for table "auth.refresh_tokens"
"""
input auth_refresh_tokens_on_conflict {
  constraint: auth_refresh_tokens_constraint!
  update_columns: [auth_refresh_tokens_update_column!]!
  where: auth_refresh_tokens_bool_exp
}

"""
ordering options when selecting data from "auth.refresh_tokens"
"""
input auth_refresh_tokens_order_by {
  account: auth_accounts_order_by
  account_id: order_by
  created_at: order_by
  expires_at: order_by
  refresh_token: order_by
}

"""
primary key columns input for table: "auth.refresh_tokens"
"""
input auth_refresh_tokens_pk_columns_input {
  refresh_token: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_select_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  refresh_token
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input auth_refresh_tokens_set_input {
  account_id: uuid
  created_at: timestamptz
  expires_at: timestamptz
  refresh_token: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum auth_refresh_tokens_update_column {
  """column name"""
  account_id

  """column name"""
  created_at

  """column name"""
  expires_at

  """column name"""
  refresh_token
}

"""
columns and relationships of "auth.roles"
"""
type auth_roles {
  """An array relationship"""
  account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """An aggregated array relationship"""
  account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """An array relationship"""
  accounts(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """An aggregated array relationship"""
  accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!
  role: String!
}

"""
aggregated selection of "auth.roles"
"""
type auth_roles_aggregate {
  aggregate: auth_roles_aggregate_fields
  nodes: [auth_roles!]!
}

"""
aggregate fields of "auth.roles"
"""
type auth_roles_aggregate_fields {
  count(columns: [auth_roles_select_column!], distinct: Boolean): Int
  max: auth_roles_max_fields
  min: auth_roles_min_fields
}

"""
order by aggregate values of table "auth.roles"
"""
input auth_roles_aggregate_order_by {
  count: order_by
  max: auth_roles_max_order_by
  min: auth_roles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.roles"
"""
input auth_roles_arr_rel_insert_input {
  data: [auth_roles_insert_input!]!
  on_conflict: auth_roles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input auth_roles_bool_exp {
  _and: [auth_roles_bool_exp]
  _not: auth_roles_bool_exp
  _or: [auth_roles_bool_exp]
  account_roles: auth_account_roles_bool_exp
  accounts: auth_accounts_bool_exp
  role: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum auth_roles_constraint {
  """unique or primary key constraint"""
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input auth_roles_insert_input {
  account_roles: auth_account_roles_arr_rel_insert_input
  accounts: auth_accounts_arr_rel_insert_input
  role: String
}

"""aggregate max on columns"""
type auth_roles_max_fields {
  role: String
}

"""
order by max() on columns of table "auth.roles"
"""
input auth_roles_max_order_by {
  role: order_by
}

"""aggregate min on columns"""
type auth_roles_min_fields {
  role: String
}

"""
order by min() on columns of table "auth.roles"
"""
input auth_roles_min_order_by {
  role: order_by
}

"""
response of any mutation on the table "auth.roles"
"""
type auth_roles_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [auth_roles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input auth_roles_obj_rel_insert_input {
  data: auth_roles_insert_input!
  on_conflict: auth_roles_on_conflict
}

"""
on conflict condition type for table "auth.roles"
"""
input auth_roles_on_conflict {
  constraint: auth_roles_constraint!
  update_columns: [auth_roles_update_column!]!
  where: auth_roles_bool_exp
}

"""
ordering options when selecting data from "auth.roles"
"""
input auth_roles_order_by {
  account_roles_aggregate: auth_account_roles_aggregate_order_by
  accounts_aggregate: auth_accounts_aggregate_order_by
  role: order_by
}

"""
primary key columns input for table: "auth.roles"
"""
input auth_roles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum auth_roles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input auth_roles_set_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum auth_roles_update_column {
  """column name"""
  role
}

scalar citext

"""
expression to compare columns of type citext. All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext
  _ilike: String
  _in: [citext!]
  _is_null: Boolean
  _like: String
  _lt: citext
  _lte: citext
  _neq: citext
  _nilike: String
  _nin: [citext!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

scalar jsonb

"""
expression to compare columns of type jsonb. All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete data from the table: "auth.account_providers"
  """
  delete_auth_account_providers(
    """filter the rows which have to be deleted"""
    where: auth_account_providers_bool_exp!
  ): auth_account_providers_mutation_response

  """
  delete single row from the table: "auth.account_providers"
  """
  delete_auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  delete data from the table: "auth.account_roles"
  """
  delete_auth_account_roles(
    """filter the rows which have to be deleted"""
    where: auth_account_roles_bool_exp!
  ): auth_account_roles_mutation_response

  """
  delete single row from the table: "auth.account_roles"
  """
  delete_auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  delete data from the table: "auth.accounts"
  """
  delete_auth_accounts(
    """filter the rows which have to be deleted"""
    where: auth_accounts_bool_exp!
  ): auth_accounts_mutation_response

  """
  delete single row from the table: "auth.accounts"
  """
  delete_auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  delete data from the table: "auth.providers"
  """
  delete_auth_providers(
    """filter the rows which have to be deleted"""
    where: auth_providers_bool_exp!
  ): auth_providers_mutation_response

  """
  delete single row from the table: "auth.providers"
  """
  delete_auth_providers_by_pk(provider: String!): auth_providers

  """
  delete data from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens(
    """filter the rows which have to be deleted"""
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  delete_auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  delete data from the table: "auth.roles"
  """
  delete_auth_roles(
    """filter the rows which have to be deleted"""
    where: auth_roles_bool_exp!
  ): auth_roles_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  delete_auth_roles_by_pk(role: String!): auth_roles

  """
  delete data from the table: "things"
  """
  delete_things(
    """filter the rows which have to be deleted"""
    where: things_bool_exp!
  ): things_mutation_response

  """
  delete single row from the table: "things"
  """
  delete_things_by_pk(id: uuid!): things

  """
  delete data from the table: "users"
  """
  delete_users(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete single row from the table: "users"
  """
  delete_users_by_pk(id: uuid!): users

  """
  insert data into the table: "auth.account_providers"
  """
  insert_auth_account_providers(
    """the rows to be inserted"""
    objects: [auth_account_providers_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_account_providers_on_conflict
  ): auth_account_providers_mutation_response

  """
  insert a single row into the table: "auth.account_providers"
  """
  insert_auth_account_providers_one(
    """the row to be inserted"""
    object: auth_account_providers_insert_input!

    """on conflict condition"""
    on_conflict: auth_account_providers_on_conflict
  ): auth_account_providers

  """
  insert data into the table: "auth.account_roles"
  """
  insert_auth_account_roles(
    """the rows to be inserted"""
    objects: [auth_account_roles_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_account_roles_on_conflict
  ): auth_account_roles_mutation_response

  """
  insert a single row into the table: "auth.account_roles"
  """
  insert_auth_account_roles_one(
    """the row to be inserted"""
    object: auth_account_roles_insert_input!

    """on conflict condition"""
    on_conflict: auth_account_roles_on_conflict
  ): auth_account_roles

  """
  insert data into the table: "auth.accounts"
  """
  insert_auth_accounts(
    """the rows to be inserted"""
    objects: [auth_accounts_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_accounts_on_conflict
  ): auth_accounts_mutation_response

  """
  insert a single row into the table: "auth.accounts"
  """
  insert_auth_accounts_one(
    """the row to be inserted"""
    object: auth_accounts_insert_input!

    """on conflict condition"""
    on_conflict: auth_accounts_on_conflict
  ): auth_accounts

  """
  insert data into the table: "auth.providers"
  """
  insert_auth_providers(
    """the rows to be inserted"""
    objects: [auth_providers_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_providers_on_conflict
  ): auth_providers_mutation_response

  """
  insert a single row into the table: "auth.providers"
  """
  insert_auth_providers_one(
    """the row to be inserted"""
    object: auth_providers_insert_input!

    """on conflict condition"""
    on_conflict: auth_providers_on_conflict
  ): auth_providers

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens(
    """the rows to be inserted"""
    objects: [auth_refresh_tokens_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insert_auth_refresh_tokens_one(
    """the row to be inserted"""
    object: auth_refresh_tokens_insert_input!

    """on conflict condition"""
    on_conflict: auth_refresh_tokens_on_conflict
  ): auth_refresh_tokens

  """
  insert data into the table: "auth.roles"
  """
  insert_auth_roles(
    """the rows to be inserted"""
    objects: [auth_roles_insert_input!]!

    """on conflict condition"""
    on_conflict: auth_roles_on_conflict
  ): auth_roles_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insert_auth_roles_one(
    """the row to be inserted"""
    object: auth_roles_insert_input!

    """on conflict condition"""
    on_conflict: auth_roles_on_conflict
  ): auth_roles

  """
  insert data into the table: "things"
  """
  insert_things(
    """the rows to be inserted"""
    objects: [things_insert_input!]!

    """on conflict condition"""
    on_conflict: things_on_conflict
  ): things_mutation_response

  """
  insert a single row into the table: "things"
  """
  insert_things_one(
    """the row to be inserted"""
    object: things_insert_input!

    """on conflict condition"""
    on_conflict: things_on_conflict
  ): things

  """
  insert data into the table: "users"
  """
  insert_users(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert a single row into the table: "users"
  """
  insert_users_one(
    """the row to be inserted"""
    object: users_insert_input!

    """on conflict condition"""
    on_conflict: users_on_conflict
  ): users

  """
  update data of the table: "auth.account_providers"
  """
  update_auth_account_providers(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_providers_set_input

    """filter the rows which have to be updated"""
    where: auth_account_providers_bool_exp!
  ): auth_account_providers_mutation_response

  """
  update single row of the table: "auth.account_providers"
  """
  update_auth_account_providers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_providers_set_input
    pk_columns: auth_account_providers_pk_columns_input!
  ): auth_account_providers

  """
  update data of the table: "auth.account_roles"
  """
  update_auth_account_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_roles_set_input

    """filter the rows which have to be updated"""
    where: auth_account_roles_bool_exp!
  ): auth_account_roles_mutation_response

  """
  update single row of the table: "auth.account_roles"
  """
  update_auth_account_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_account_roles_set_input
    pk_columns: auth_account_roles_pk_columns_input!
  ): auth_account_roles

  """
  update data of the table: "auth.accounts"
  """
  update_auth_accounts(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_accounts_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_accounts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_accounts_set_input

    """filter the rows which have to be updated"""
    where: auth_accounts_bool_exp!
  ): auth_accounts_mutation_response

  """
  update single row of the table: "auth.accounts"
  """
  update_auth_accounts_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: auth_accounts_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: auth_accounts_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: auth_accounts_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: auth_accounts_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: auth_accounts_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: auth_accounts_set_input
    pk_columns: auth_accounts_pk_columns_input!
  ): auth_accounts

  """
  update data of the table: "auth.providers"
  """
  update_auth_providers(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_providers_set_input

    """filter the rows which have to be updated"""
    where: auth_providers_bool_exp!
  ): auth_providers_mutation_response

  """
  update single row of the table: "auth.providers"
  """
  update_auth_providers_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_providers_set_input
    pk_columns: auth_providers_pk_columns_input!
  ): auth_providers

  """
  update data of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_refresh_tokens_set_input

    """filter the rows which have to be updated"""
    where: auth_refresh_tokens_bool_exp!
  ): auth_refresh_tokens_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  update_auth_refresh_tokens_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_refresh_tokens_set_input
    pk_columns: auth_refresh_tokens_pk_columns_input!
  ): auth_refresh_tokens

  """
  update data of the table: "auth.roles"
  """
  update_auth_roles(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_roles_set_input

    """filter the rows which have to be updated"""
    where: auth_roles_bool_exp!
  ): auth_roles_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  update_auth_roles_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: auth_roles_set_input
    pk_columns: auth_roles_pk_columns_input!
  ): auth_roles

  """
  update data of the table: "things"
  """
  update_things(
    """sets the columns of the filtered rows to the given values"""
    _set: things_set_input

    """filter the rows which have to be updated"""
    where: things_bool_exp!
  ): things_mutation_response

  """
  update single row of the table: "things"
  """
  update_things_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: things_set_input
    pk_columns: things_pk_columns_input!
  ): things

  """
  update data of the table: "users"
  """
  update_users(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update single row of the table: "users"
  """
  update_users_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
}

"""column ordering options"""
enum order_by {
  """in the ascending order, nulls last"""
  asc

  """in the ascending order, nulls first"""
  asc_nulls_first

  """in the ascending order, nulls last"""
  asc_nulls_last

  """in the descending order, nulls first"""
  desc

  """in the descending order, nulls first"""
  desc_nulls_first

  """in the descending order, nulls last"""
  desc_nulls_last
}

"""query root"""
type query_root {
  """
  fetch data from the table: "auth.account_providers"
  """
  auth_account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  fetch aggregated fields from the table: "auth.account_providers"
  """
  auth_account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  fetch data from the table: "auth.account_providers" using primary key columns
  """
  auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  fetch data from the table: "auth.account_roles"
  """
  auth_account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  fetch aggregated fields from the table: "auth.account_roles"
  """
  auth_account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  fetch data from the table: "auth.account_roles" using primary key columns
  """
  auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  fetch data from the table: "auth.accounts"
  """
  auth_accounts(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  fetch aggregated fields from the table: "auth.accounts"
  """
  auth_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!

  """fetch data from the table: "auth.accounts" using primary key columns"""
  auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  fetch data from the table: "auth.providers"
  """
  auth_providers(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): [auth_providers!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  auth_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): auth_providers_aggregate!

  """fetch data from the table: "auth.providers" using primary key columns"""
  auth_providers_by_pk(provider: String!): auth_providers

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  fetch data from the table: "auth.roles"
  """
  auth_roles(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): [auth_roles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  auth_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): auth_roles_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  auth_roles_by_pk(role: String!): auth_roles

  """
  fetch data from the table: "things"
  """
  things(
    """distinct select on columns"""
    distinct_on: [things_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [things_order_by!]

    """filter the rows returned"""
    where: things_bool_exp
  ): [things!]!

  """
  fetch aggregated fields from the table: "things"
  """
  things_aggregate(
    """distinct select on columns"""
    distinct_on: [things_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [things_order_by!]

    """filter the rows returned"""
    where: things_bool_exp
  ): things_aggregate!

  """fetch data from the table: "things" using primary key columns"""
  things_by_pk(id: uuid!): things

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
}

"""subscription root"""
type subscription_root {
  """
  fetch data from the table: "auth.account_providers"
  """
  auth_account_providers(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): [auth_account_providers!]!

  """
  fetch aggregated fields from the table: "auth.account_providers"
  """
  auth_account_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_providers_order_by!]

    """filter the rows returned"""
    where: auth_account_providers_bool_exp
  ): auth_account_providers_aggregate!

  """
  fetch data from the table: "auth.account_providers" using primary key columns
  """
  auth_account_providers_by_pk(id: uuid!): auth_account_providers

  """
  fetch data from the table: "auth.account_roles"
  """
  auth_account_roles(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): [auth_account_roles!]!

  """
  fetch aggregated fields from the table: "auth.account_roles"
  """
  auth_account_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_account_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_account_roles_order_by!]

    """filter the rows returned"""
    where: auth_account_roles_bool_exp
  ): auth_account_roles_aggregate!

  """
  fetch data from the table: "auth.account_roles" using primary key columns
  """
  auth_account_roles_by_pk(id: uuid!): auth_account_roles

  """
  fetch data from the table: "auth.accounts"
  """
  auth_accounts(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): [auth_accounts!]!

  """
  fetch aggregated fields from the table: "auth.accounts"
  """
  auth_accounts_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_accounts_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_accounts_order_by!]

    """filter the rows returned"""
    where: auth_accounts_bool_exp
  ): auth_accounts_aggregate!

  """fetch data from the table: "auth.accounts" using primary key columns"""
  auth_accounts_by_pk(id: uuid!): auth_accounts

  """
  fetch data from the table: "auth.providers"
  """
  auth_providers(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): [auth_providers!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  auth_providers_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_providers_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_providers_order_by!]

    """filter the rows returned"""
    where: auth_providers_bool_exp
  ): auth_providers_aggregate!

  """fetch data from the table: "auth.providers" using primary key columns"""
  auth_providers_by_pk(provider: String!): auth_providers

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): [auth_refresh_tokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  auth_refresh_tokens_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_refresh_tokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_refresh_tokens_order_by!]

    """filter the rows returned"""
    where: auth_refresh_tokens_bool_exp
  ): auth_refresh_tokens_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  auth_refresh_tokens_by_pk(refresh_token: uuid!): auth_refresh_tokens

  """
  fetch data from the table: "auth.roles"
  """
  auth_roles(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): [auth_roles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  auth_roles_aggregate(
    """distinct select on columns"""
    distinct_on: [auth_roles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [auth_roles_order_by!]

    """filter the rows returned"""
    where: auth_roles_bool_exp
  ): auth_roles_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  auth_roles_by_pk(role: String!): auth_roles

  """
  fetch data from the table: "things"
  """
  things(
    """distinct select on columns"""
    distinct_on: [things_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [things_order_by!]

    """filter the rows returned"""
    where: things_bool_exp
  ): [things!]!

  """
  fetch aggregated fields from the table: "things"
  """
  things_aggregate(
    """distinct select on columns"""
    distinct_on: [things_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [things_order_by!]

    """filter the rows returned"""
    where: things_bool_exp
  ): things_aggregate!

  """fetch data from the table: "things" using primary key columns"""
  things_by_pk(id: uuid!): things

  """
  fetch data from the table: "users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """
  fetch aggregated fields from the table: "users"
  """
  users_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """fetch data from the table: "users" using primary key columns"""
  users_by_pk(id: uuid!): users
}

"""
columns and relationships of "things"
"""
type things {
  created_at: timestamptz!
  id: uuid!
  name: String!

  """An object relationship"""
  owner: users!
  owner_id: uuid!
  updated_at: timestamptz!
}

"""
aggregated selection of "things"
"""
type things_aggregate {
  aggregate: things_aggregate_fields
  nodes: [things!]!
}

"""
aggregate fields of "things"
"""
type things_aggregate_fields {
  count(columns: [things_select_column!], distinct: Boolean): Int
  max: things_max_fields
  min: things_min_fields
}

"""
order by aggregate values of table "things"
"""
input things_aggregate_order_by {
  count: order_by
  max: things_max_order_by
  min: things_min_order_by
}

"""
input type for inserting array relation for remote table "things"
"""
input things_arr_rel_insert_input {
  data: [things_insert_input!]!
  on_conflict: things_on_conflict
}

"""
Boolean expression to filter rows from the table "things". All fields are combined with a logical 'AND'.
"""
input things_bool_exp {
  _and: [things_bool_exp]
  _not: things_bool_exp
  _or: [things_bool_exp]
  created_at: timestamptz_comparison_exp
  id: uuid_comparison_exp
  name: String_comparison_exp
  owner: users_bool_exp
  owner_id: uuid_comparison_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "things"
"""
enum things_constraint {
  """unique or primary key constraint"""
  sharable_pkey
}

"""
input type for inserting data into table "things"
"""
input things_insert_input {
  created_at: timestamptz
  id: uuid
  name: String
  owner: users_obj_rel_insert_input
  owner_id: uuid
  updated_at: timestamptz
}

"""aggregate max on columns"""
type things_max_fields {
  created_at: timestamptz
  id: uuid
  name: String
  owner_id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "things"
"""
input things_max_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  owner_id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type things_min_fields {
  created_at: timestamptz
  id: uuid
  name: String
  owner_id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "things"
"""
input things_min_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  owner_id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "things"
"""
type things_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [things!]!
}

"""
input type for inserting object relation for remote table "things"
"""
input things_obj_rel_insert_input {
  data: things_insert_input!
  on_conflict: things_on_conflict
}

"""
on conflict condition type for table "things"
"""
input things_on_conflict {
  constraint: things_constraint!
  update_columns: [things_update_column!]!
  where: things_bool_exp
}

"""
ordering options when selecting data from "things"
"""
input things_order_by {
  created_at: order_by
  id: order_by
  name: order_by
  owner: users_order_by
  owner_id: order_by
  updated_at: order_by
}

"""
primary key columns input for table: "things"
"""
input things_pk_columns_input {
  id: uuid!
}

"""
select columns of table "things"
"""
enum things_select_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  owner_id

  """column name"""
  updated_at
}

"""
input type for updating data in table "things"
"""
input things_set_input {
  created_at: timestamptz
  id: uuid
  name: String
  owner_id: uuid
  updated_at: timestamptz
}

"""
update columns of table "things"
"""
enum things_update_column {
  """column name"""
  created_at

  """column name"""
  id

  """column name"""
  name

  """column name"""
  owner_id

  """column name"""
  updated_at
}

scalar timestamptz

"""
expression to compare columns of type timestamptz. All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "users"
"""
type users {
  """An object relationship"""
  account: auth_accounts
  avatar_url: String
  created_at: timestamptz!
  display_name: String
  id: uuid!

  """An array relationship"""
  things(
    """distinct select on columns"""
    distinct_on: [things_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [things_order_by!]

    """filter the rows returned"""
    where: things_bool_exp
  ): [things!]!

  """An aggregated array relationship"""
  things_aggregate(
    """distinct select on columns"""
    distinct_on: [things_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [things_order_by!]

    """filter the rows returned"""
    where: things_bool_exp
  ): things_aggregate!
  updated_at: timestamptz!
}

"""
aggregated selection of "users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""
input type for inserting array relation for remote table "users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp]
  _not: users_bool_exp
  _or: [users_bool_exp]
  account: auth_accounts_bool_exp
  avatar_url: String_comparison_exp
  created_at: timestamptz_comparison_exp
  display_name: String_comparison_exp
  id: uuid_comparison_exp
  things: things_bool_exp
  updated_at: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_pkey
}

"""
input type for inserting data into table "users"
"""
input users_insert_input {
  account: auth_accounts_obj_rel_insert_input
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  things: things_arr_rel_insert_input
  updated_at: timestamptz
}

"""aggregate max on columns"""
type users_max_fields {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
order by max() on columns of table "users"
"""
input users_max_order_by {
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
order by min() on columns of table "users"
"""
input users_min_order_by {
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  updated_at: order_by
}

"""
response of any mutation on the table "users"
"""
type users_mutation_response {
  """number of affected rows by the mutation"""
  affected_rows: Int!

  """data of the affected rows by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

"""
on conflict condition type for table "users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

"""
ordering options when selecting data from "users"
"""
input users_order_by {
  account: auth_accounts_order_by
  avatar_url: order_by
  created_at: order_by
  display_name: order_by
  id: order_by
  things_aggregate: things_aggregate_order_by
  updated_at: order_by
}

"""
primary key columns input for table: "users"
"""
input users_pk_columns_input {
  id: uuid!
}

"""
select columns of table "users"
"""
enum users_select_column {
  """column name"""
  avatar_url

  """column name"""
  created_at

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  updated_at
}

"""
input type for updating data in table "users"
"""
input users_set_input {
  avatar_url: String
  created_at: timestamptz
  display_name: String
  id: uuid
  updated_at: timestamptz
}

"""
update columns of table "users"
"""
enum users_update_column {
  """column name"""
  avatar_url

  """column name"""
  created_at

  """column name"""
  display_name

  """column name"""
  id

  """column name"""
  updated_at
}

scalar uuid

"""
expression to compare columns of type uuid. All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}
